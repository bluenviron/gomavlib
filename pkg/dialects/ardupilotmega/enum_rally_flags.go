//autogenerated:yes
//nolint:revive,misspell,govet,lll,dupl,gocritic
package ardupilotmega

import (
	"fmt"
	"strings"
)

// Flags in RALLY_POINT message.
type RALLY_FLAGS uint32

const (
	// Flag set when requiring favorable winds for landing.
	FAVORABLE_WIND RALLY_FLAGS = 1
	// Flag set when plane is to immediately descend to break altitude and land without GCS intervention. Flag not set when plane is to loiter at Rally point until commanded to land.
	LAND_IMMEDIATELY RALLY_FLAGS = 2
)

var labels_RALLY_FLAGS = map[RALLY_FLAGS]string{
	FAVORABLE_WIND:   "FAVORABLE_WIND",
	LAND_IMMEDIATELY: "LAND_IMMEDIATELY",
}

// MarshalText implements the encoding.TextMarshaler interface.
func (e RALLY_FLAGS) MarshalText() ([]byte, error) {
	var names []string
	for mask, label := range labels_RALLY_FLAGS {
		if e&mask == mask {
			names = append(names, label)
		}
	}
	return []byte(strings.Join(names, " | ")), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface.
func (e *RALLY_FLAGS) UnmarshalText(text []byte) error {
	labels := strings.Split(string(text), " | ")
	var mask RALLY_FLAGS
	for _, label := range labels {
		found := false
		for value, l := range labels_RALLY_FLAGS {
			if l == label {
				mask |= value
				found = true
				break
			}
		}
		if !found {
			return fmt.Errorf("invalid label '%s'", label)
		}
	}
	*e = mask
	return nil
}

// String implements the fmt.Stringer interface.
func (e RALLY_FLAGS) String() string {
	val, _ := e.MarshalText()
	return string(val)
}
