//autogenerated:yes
//nolint:revive,misspell,govet,lll,dupl,gocritic
package common

import (
	"fmt"
	"strings"
)

// A data stream is not a fixed set of messages, but rather a
// recommendation to the autopilot software. Individual autopilots may or may not obey
// the recommended messages.
type MAV_DATA_STREAM uint32

const (
	// Enable all data streams
	MAV_DATA_STREAM_ALL MAV_DATA_STREAM = 0
	// Enable IMU_RAW, GPS_RAW, GPS_STATUS packets.
	MAV_DATA_STREAM_RAW_SENSORS MAV_DATA_STREAM = 1
	// Enable GPS_STATUS, CONTROL_STATUS, AUX_STATUS
	MAV_DATA_STREAM_EXTENDED_STATUS MAV_DATA_STREAM = 2
	// Enable RC_CHANNELS_SCALED, RC_CHANNELS_RAW, SERVO_OUTPUT_RAW
	MAV_DATA_STREAM_RC_CHANNELS MAV_DATA_STREAM = 3
	// Enable ATTITUDE_CONTROLLER_OUTPUT, POSITION_CONTROLLER_OUTPUT, NAV_CONTROLLER_OUTPUT.
	MAV_DATA_STREAM_RAW_CONTROLLER MAV_DATA_STREAM = 4
	// Enable LOCAL_POSITION, GLOBAL_POSITION_INT messages.
	MAV_DATA_STREAM_POSITION MAV_DATA_STREAM = 6
	// Dependent on the autopilot
	MAV_DATA_STREAM_EXTRA1 MAV_DATA_STREAM = 10
	// Dependent on the autopilot
	MAV_DATA_STREAM_EXTRA2 MAV_DATA_STREAM = 11
	// Dependent on the autopilot
	MAV_DATA_STREAM_EXTRA3 MAV_DATA_STREAM = 12
)

var labels_MAV_DATA_STREAM = map[MAV_DATA_STREAM]string{
	MAV_DATA_STREAM_ALL:             "MAV_DATA_STREAM_ALL",
	MAV_DATA_STREAM_RAW_SENSORS:     "MAV_DATA_STREAM_RAW_SENSORS",
	MAV_DATA_STREAM_EXTENDED_STATUS: "MAV_DATA_STREAM_EXTENDED_STATUS",
	MAV_DATA_STREAM_RC_CHANNELS:     "MAV_DATA_STREAM_RC_CHANNELS",
	MAV_DATA_STREAM_RAW_CONTROLLER:  "MAV_DATA_STREAM_RAW_CONTROLLER",
	MAV_DATA_STREAM_POSITION:        "MAV_DATA_STREAM_POSITION",
	MAV_DATA_STREAM_EXTRA1:          "MAV_DATA_STREAM_EXTRA1",
	MAV_DATA_STREAM_EXTRA2:          "MAV_DATA_STREAM_EXTRA2",
	MAV_DATA_STREAM_EXTRA3:          "MAV_DATA_STREAM_EXTRA3",
}

// MarshalText implements the encoding.TextMarshaler interface.
func (e MAV_DATA_STREAM) MarshalText() ([]byte, error) {
	var names []string
	for mask, label := range labels_MAV_DATA_STREAM {
		if e&mask == mask {
			names = append(names, label)
		}
	}
	return []byte(strings.Join(names, " | ")), nil
}

// UnmarshalText implements the encoding.TextUnmarshaler interface.
func (e *MAV_DATA_STREAM) UnmarshalText(text []byte) error {
	labels := strings.Split(string(text), " | ")
	var mask MAV_DATA_STREAM
	for _, label := range labels {
		found := false
		for value, l := range labels_MAV_DATA_STREAM {
			if l == label {
				mask |= value
				found = true
				break
			}
		}
		if !found {
			return fmt.Errorf("invalid label '%s'", label)
		}
	}
	*e = mask
	return nil
}

// String implements the fmt.Stringer interface.
func (e MAV_DATA_STREAM) String() string {
	val, _ := e.MarshalText()
	return string(val)
}
