//autogenerated:yes
//nolint:revive,misspell,govet,lll
package development

// ESC EEPROM data message for reading and writing ESC configuration.
// Supports multiple ESC firmware types including AM32, Bluejay, and BLHeli32.
// ESC data is read by sending the MAV_CMD_REQUEST_MESSAGE with `param1=292` and `param2=esc_index`, where esc_index is the zero-indexed ESC number for the corresponding motor, and 255 is used to request data for all ESC.
// The message can be sent to set the ESC value.
// For write requests, a bitmask allows selective writing of specific bytes to avoid corrupting unchanged values.
// The data format is opaque to the autopilot.
// A GCS is required to understand the format in order to create an appropriate UI for display and setting configuration values, and to inform users when the ESC uses an unsupported data format.
// Note that for AM32 EEPROMs the data layout is defined in: https://github.com/am32-firmware/AM32/blob/main/Inc/eeprom.h (the second byte in the structure is the eeprom_version).
// The firmware field indicates which ESC firmware is in use, allowing the GCS to interpret the data correctly.
type MessageEscEeprom struct {
	// System ID (ID of target system, normally flight controller).
	TargetSystem uint8
	// Component ID (normally 0 for broadcast).
	TargetComponent uint8
	// ESC firmware type.
	Firmware ESC_FIRMWARE `mavenum:"uint8"`
	// Zero-indexed sequence number of this message when multiple messages are required to transfer the complete EEPROM data. The first message has index 0. For single-message transfers, set to 0.
	MsgIndex uint8
	// Total number of messages required to transfer the complete EEPROM data. For single-message transfers, set to 1. Receivers should collect all messages from index 0 to msg_count-1 before reconstructing the complete data.
	MsgCount uint8
	// Index of the ESC (0 = ESC1, 1 = ESC2, etc.).
	EscIndex uint8
	// Bitmask indicating which bytes in the data array should be written. Each bit corresponds to a byte index in the data array (bit 0 of write_mask[0] = data[0], bit 31 of write_mask[0] = data[31], bit 0 of write_mask[1] = data[32], etc.). Set bits indicate bytes to write, cleared bits indicate bytes to skip. This allows precise updates of individual parameters without overwriting the entire EEPROM.
	WriteMask [6]uint32
	// Number of valid bytes in data array.
	Length uint8
	// Raw ESC EEPROM data. Unused bytes should be set to zero.
	Data [192]uint8
}

// GetID implements the message.Message interface.
func (*MessageEscEeprom) GetID() uint32 {
	return 292
}
